# 並行控制
- 定義：
    - 讓多筆交易可以在同一時間存取同一筆資料
    - 並行控制讓多筆交易在並行的狀況下運作而不會互相干擾，確保交易的孤立性，提高交易效率
- 目的：
    - 多筆交易可同時進行，並不會互相干擾
    - 減低交易的回覆時間
    - 增加交易的產出

# 並行控制不佳所導致的問題
- 遺失更新
- 不一致分析
- 未確認相依

# 遺失更新
- 當多筆交易交錯進行，並針對相同資料項做讀取，可能會使資料項目的內容值不正確
- 會產生遺失更新的排程，一定不是可序列化排程

# 不一致分析
- 又稱**不正確總合**問題
- 一筆交易正在對某些資料項目做聚合函數運算，若此時期中一個資料項目被其他交易修改，造成聚合結果不正確
- 因時間點不一致造成

# 未確認相依
- 交易A已更新某一個資料項，但尚未確認(Commit)時，此資料項又被另一個交易B所存取，但是先前的交易A因故需要撤回(Abort/Rollback)，因此交易B讀到一個不應該讀的值

# 交易並行可能會發生的問題
- 死結
- 活結
- 餓死

# 死結
- 當兩交易進行時，各自都佔有某些資源，卻企圖奪取對方的資源，就會造成一種互相等待對方釋放資源的情形
- 形成死結的必要條件
    - 互斥：同一資源不可被兩個以上的交易共用，資源會被鎖定
    - 持有並等待：各交易都佔有某些資源，並等候其他交易釋放資源
    - 不可搶奪：不可強取已被占用之資源
    - 循環式等待：等待形成迴圈
![](http://i.imgur.com/xkG77zu.png)

# 活結與餓死
- 若交易有**優先權**，優先權較高之交易持續得到資源，而優先權較低的交易一直得不到資源，而進入活結的狀態
- 交易處於活結狀態太久 -> 餓死

# 餓死的問題解決
- 等-死方法 (wait-die)
    - 當交易Ti要求一個被Tj所持有的資源時，去比對兩筆交易的時間戳記，若：
        - Ti時間戳記>Tj，則撤回Ti
        - Ti時間戳記<Tj，則Ti允許等待
    - 基於**不可強奪**為基礎
- 傷-等方法 (wound-wait scheme)
    - 等-死的相反
    - 當交易Ti要求一個被Tj所持有的資源時，去比對兩筆交易的時間戳記，若：
        - Ti時間戳記<Tj，直接搶奪Tj資源，Tj撤回
        - Ti時間戳記>Tj，則Ti允許等待

# 並型控制的技術
- 鎖定：當交易欲存取某資料項目時，必須將此資料鎖住，直到存取結束才解鎖
- 時間戳記：每個交易依照其進入資料庫系統的先後，給予一個時間戳記，以時間戳記的大小來判斷交易的優先權
- 多重版本並行控制：
    - 以時間為基礎，會在每次資料項目被修改時，保留舊的版本
    - 所以在並行執行時，會自動選擇適合的版本避免不一致的情況
    - 較浪費空間
- 樂觀並行控制
    - 不在交易期間進行檢查，而是在交易完成後才開始檢查
    - 若交易違反可序列化的結果，選擇影響較小的交易做撤回

# 鎖定
- 用一個變數記錄資料項目的狀態，並決定何種動作**允許**何種**不允許**
    - 二元鎖定
    - 共享互斥鎖定
    - 兩階段鎖定

# 二元鎖定
- 交易欲存取資料項目X時，即將X鎖定，直到存取完畢，再解除對X的鎖定
- 將資料項分成兩種狀態
    - 鎖定(Lock)
    - 解除鎖定(Unlock)
- 缺點：
    - 不能保證排程為可序列化
    - 可能產生死結
    - 可能產生活結或餓死狀態
    - 並行程度不佳
![](http://i.mgur.com/LlntAyT.png)

# 共享互斥鎖定
- 改善二元鎖定過於嚴格、並行度不佳特性
- 若只是從事read功能，並不需要鎖定資料項；只有在從事write才需要所定資料項
- 共享互斥鎖定又稱多元鎖定，將二元鎖定中的Lock分為共享鎖定與互斥鎖定兩種，較二元鎖定有彈性。
- 將資料項分為三種狀態
    - 共享鎖定：又稱讀取鎖定，仍可讀取
    - 互斥鎖定：又稱寫入鎖定，不能讀取或寫入
    - 解除鎖定：可以被讀取或寫入
- 鎖定的升級與降級
    - 升級：unlock -> read lock -> write lock
    - 降級：write lock -> read lock -> unlock
- 缺點：
    - 不能保證排程為可序列化
    - 可能產生死結、活結和餓死

![](http://.imgur.com/PlQoNwL.png)


# 兩階段鎖定
- 擴展階段：允許升級或鎖定動作
- 收縮階段：允許降級或解鎖動作
- 種類
    - 基本型2PL：交易會逐漸鎖定資料項目
    - 保守型2PL
        - 在交易執行前，先鎖定所有需要的資料項目
        - 若有資料項目無法鎖定，則全部不鎖，直到全部鎖定再開始交易
        - 不太會有死結
        - 擴展階段短，收縮階段長
    - 嚴格型2PL
        - 交易階段不會釋放任何鎖定，直到交易結束
        - 可能會有死結
        - 擴展階段長，收縮階段短
- 優點：遵守2PL要求的排程，一定是可序列化排程
- 缺點： 可能產生活

# 時間戳記排序法
- 時間戳記：交易進入資料庫的時間，交易開始的時間
- 表示法：TS(T)
- 以時間戳記為基礎的並型控制並不會鎖定資料項，所以不會造成死結
- 針對資料項會有兩種不同的時間戳記
    - 讀取時間戳記
        - Read-TS(x) = TS(Ti)
        - 資料項目x的讀取時間戳記，表示所有已成功讀取x的交易中，時間戳記最大的(最後一個交易)
    - 寫入時間戳記
        - Write-TS(x) = TS(Ti)
        - 資料項目的x的寫入時間戳記，表示所有已成功寫入x的交易中，時間戳記最大的(最後一個交易)
- 當交易T執行一個write(x)動作
    - 若Read-TS(x)>TS(T)或Write-TS(x)>TS(T)，則交易不允許對x寫入，將交易T取消並撤回；
    - 若無上述情況，允許對x的寫入，並將Write-TS(x)設為TS(x)
- 當交易T執行一個read(x)動作
    - 若Write-TS(x)>TS(T)，則read(x)不允許，將交易T取消並撤回；
    - 若Write-TS(x)<TS(T)，則read(x)允許，並將Read-TS(x)設為MAX(TS(T),Original Read-TS(x))
- 優點：
    - 保證程序都可序列化
- 缺點：
    - 造成連鎖性撤回，降低效率


# 樂觀並行控制
- 因為鎖定機制或時間戳記都必須在執行資料庫動作之前進行一定程度的檢查，但是過多的檢查會降低交易執行的效率
- 核心觀念：
    - 假設交易皆可順利且正確的進行，因此在交易過程間不需要進行任何檢查
    - 交易執行時，對資料項目的變更操作(Write)並非直接對資料庫做修改，而是對資料庫項目的副本去做修改，等到交易結束時再去檢查這些變更操作是否符合可序列化特性
    - 確認符合可序列化特性時，再從副本變更到資料庫中；反之，則交易將被撤回(Abort)
- 階段：
    1. 讀取：從資料庫讀取資料項目，並產生副本
    2. 確認：執行檢查，確保交易修改到資料庫的操作沒有違反可序列化
    3. 寫入：如果確認階段通過，將交易結果寫入資料庫，否則取消操作，撤回交易
- 適用情形：
    - 交易很少發生不一致的情況
- 樂觀並行控制的優點：
    - 保証排程皆為可序列化
    - 避免死結發生
    - 結合Wait-die或Wound-wait方法可避免活結或餓死發生
    - 不一致情況甚少發生時，可加快系統執行效率
- 缺點：
    - 若經常發生不一致的狀況，樂觀並行控制會產生大量的撤回或復原工作。

# 多重版本並行控制
- 以時間為基礎，會在每次資料項目被修改時，保留舊的版本
- 所以在並行執行時，會自動選擇適合的版本避免不一致的情況
- 較浪費空間
- 優點：
    - 保証排程皆為可序列化
    - 避免死結發生
    - 結合Wait-die或Wound-wait方法可避免活結或餓死發生
    - 加快讀取及寫入速度
- 缺點：
    - 可能產生連鎖性撤回(Cascading Rollback)，降低執行效率
    - 需要較多記憶體，以維持每個資料項目的多個版本

# 並行控制技術比較
||可序列化|死結|活結|餓死|

# 復原
- 定義：指在資料庫發生失敗後，重新回到一個已知正確狀態的方法
- 失敗的種類
    - 非毀滅性故障
    - 毀滅性故障

# 非毀滅性故障
- 一般是指導致主記憶體資料內容消失，但永久性儲存媒體中的資料仍完好的狀態
- 復原方式
    - 利用系統日誌(System Journal, System Log)從事復原

# 交易回復技術
- 延遲更新

# 延遲更新
- 延遲任何真正寫入資料庫的更新，直到交易成功的完成並且到達確認點(Commit Point)為止。